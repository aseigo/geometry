defmodule Geometry.MultiPolygonMTest do
  # This file is auto-generated by `mix geometry.gen`.
  # The ZM version of this file is used as a template.

  use ExUnit.Case, async: true

  alias Geometry.{
    MultiPolygonM,
    PointM,
    PolygonM
  }

  doctest Geometry.MultiPolygonM, import: true

  @moduletag :multi_plygon

  describe "to_geo_json/1" do
    test "returns geo-json-term" do
      geo_json =
        [
          [{6, 2, 4}, {8, 2, 5}, {8, 4, 6}, {6, 2, 4}],
          [[{60, 20, 40}, {80, 20, 50}, {80, 40, 60}, {60, 20, 40}]],
          [
            [{1, 1, 4}, {9, 1, 5}, {9, 8, 6}, {1, 1, 4}],
            [{6, 2, 3}, {7, 2, 7}, {7, 3, 4}, {6, 2, 3}]
          ]
        ]
        |> MultiPolygonM.from_coordinates()
        |> MultiPolygonM.to_geo_json()

      assert GeoJsonValidator.valid?(geo_json)

      assert geo_json |> Map.keys() |> Enum.sort() == ["coordinates", "type"]
      assert Map.get(geo_json, "type") == "MultiPolygon"

      assert geo_json |> Map.get("coordinates") |> Enum.sort() ==
               [
                 [
                   [[1, 1, 4], [9, 1, 5], [9, 8, 6], [1, 1, 4]],
                   [[6, 2, 3], [7, 2, 7], [7, 3, 4], [6, 2, 3]]
                 ],
                 [
                   [[6, 2, 4], [8, 2, 5], [8, 4, 6], [6, 2, 4]]
                 ],
                 [
                   [[60, 20, 40], [80, 20, 50], [80, 40, 60], [60, 20, 40]]
                 ]
               ]
    end
  end

  describe "from_geo_json!/1" do
    test "returns MultiPolygonM" do
      geo_json =
        Jason.decode!("""
         {
           "type": "MultiPolygon",
           "coordinates": [
             [
               [[6, 2, 4], [8, 2, 5], [8, 4, 6], [6, 2, 4]]
             ], [
               [[1, 1, 4], [9, 1, 5], [9, 8, 6], [1, 1, 4]],
               [[6, 2, 3], [7, 2, 7], [7, 3, 4], [6, 2, 3]]
             ]
           ]
         }
        """)

      multi_polygon = %MultiPolygonM{
        polygons:
          MapSet.new([
            %PolygonM{
              exterior: [
                %PointM{x: 1, y: 1, m: 4},
                %PointM{x: 9, y: 1, m: 5},
                %PointM{x: 9, y: 8, m: 6},
                %PointM{x: 1, y: 1, m: 4}
              ],
              interiors: [
                [
                  %PointM{x: 6, y: 2, m: 3},
                  %PointM{x: 7, y: 2, m: 7},
                  %PointM{x: 7, y: 3, m: 4},
                  %PointM{x: 6, y: 2, m: 3}
                ]
              ]
            },
            %PolygonM{
              exterior: [
                %PointM{x: 6, y: 2, m: 4},
                %PointM{x: 8, y: 2, m: 5},
                %PointM{x: 8, y: 4, m: 6},
                %PointM{x: 6, y: 2, m: 4}
              ],
              interiors: []
            }
          ])
      }

      assert MultiPolygonM.from_geo_json!(geo_json) == multi_polygon
    end

    test "raises an error for an invalid geo-json-term" do
      message = "type not found"

      assert_raise Geometry.Error, message, fn ->
        MultiPolygonM.from_geo_json!(%{})
      end
    end
  end

  describe "from_wkt/1" do
    test "returns MultiPolygonM" do
      wkt = """
      MULTIPOLYGON M (
        (
           (40 40 20, 20 45 10, 45 30 30, 40 40 20)
        ), (
           (20 35 10, 10 30 20, 10 10 15, 30 5 15, 45 20 16, 20 35 10),
           (30 20 15, 20 15 10, 20 25 25, 30 20 15)
        )
      )
      """

      multi_polygon = %MultiPolygonM{
        polygons:
          MapSet.new([
            %PolygonM{
              exterior: [
                %PointM{x: 20, y: 35, m: 10},
                %PointM{x: 10, y: 30, m: 20},
                %PointM{x: 10, y: 10, m: 15},
                %PointM{x: 30, y: 5, m: 15},
                %PointM{x: 45, y: 20, m: 16},
                %PointM{x: 20, y: 35, m: 10}
              ],
              interiors: [
                [
                  %PointM{x: 30, y: 20, m: 15},
                  %PointM{x: 20, y: 15, m: 10},
                  %PointM{x: 20, y: 25, m: 25},
                  %PointM{x: 30, y: 20, m: 15}
                ]
              ]
            },
            %PolygonM{
              exterior: [
                %PointM{x: 40, y: 40, m: 20},
                %PointM{x: 20, y: 45, m: 10},
                %PointM{x: 45, y: 30, m: 30},
                %PointM{x: 40, y: 40, m: 20}
              ],
              interiors: []
            }
          ])
      }

      assert MultiPolygonM.from_wkt(wkt) == {:ok, multi_polygon}
    end
  end

  describe "from_wkt!/1" do
    test "returns MultiPolygonM" do
      wkt = """
       MULTIPOLYGON M (
         (
            (40 40 20, 20 45 10, 45 30 30, 40 40 20)
         ), (
            (20 35 10, 10 30 20, 10 10 15, 30 5 15, 45 20 16, 20 35 10),
            (30 20 15, 20 15 10, 20 25 25, 30 20 15)
         )
      )
      """

      multi_polygon = %MultiPolygonM{
        polygons:
          MapSet.new([
            %PolygonM{
              exterior: [
                %PointM{x: 20, y: 35, m: 10},
                %PointM{x: 10, y: 30, m: 20},
                %PointM{x: 10, y: 10, m: 15},
                %PointM{x: 30, y: 5, m: 15},
                %PointM{x: 45, y: 20, m: 16},
                %PointM{x: 20, y: 35, m: 10}
              ],
              interiors: [
                [
                  %PointM{x: 30, y: 20, m: 15},
                  %PointM{x: 20, y: 15, m: 10},
                  %PointM{x: 20, y: 25, m: 25},
                  %PointM{x: 30, y: 20, m: 15}
                ]
              ]
            },
            %PolygonM{
              exterior: [
                %PointM{x: 40, y: 40, m: 20},
                %PointM{x: 20, y: 45, m: 10},
                %PointM{x: 45, y: 30, m: 30},
                %PointM{x: 40, y: 40, m: 20}
              ],
              interiors: []
            }
          ])
      }

      assert MultiPolygonM.from_wkt!(wkt) == multi_polygon
    end

    test "returns MultiPolygonM with SRID" do
      wkt = """
       SRID=1234;MULTIPOLYGON M (
         (
            (40 40 20, 20 45 10, 45 30 30, 40 40 20)
         ), (
            (20 35 10, 10 30 20, 10 10 15, 30 5 15, 45 20 16, 20 35 10),
            (30 20 15, 20 15 10, 20 25 25, 30 20 15)
         )
      )
      """

      multi_polygon = %MultiPolygonM{
        polygons:
          MapSet.new([
            %PolygonM{
              exterior: [
                %PointM{x: 20, y: 35, m: 10},
                %PointM{x: 10, y: 30, m: 20},
                %PointM{x: 10, y: 10, m: 15},
                %PointM{x: 30, y: 5, m: 15},
                %PointM{x: 45, y: 20, m: 16},
                %PointM{x: 20, y: 35, m: 10}
              ],
              interiors: [
                [
                  %PointM{x: 30, y: 20, m: 15},
                  %PointM{x: 20, y: 15, m: 10},
                  %PointM{x: 20, y: 25, m: 25},
                  %PointM{x: 30, y: 20, m: 15}
                ]
              ]
            },
            %PolygonM{
              exterior: [
                %PointM{x: 40, y: 40, m: 20},
                %PointM{x: 20, y: 45, m: 10},
                %PointM{x: 45, y: 30, m: 30},
                %PointM{x: 40, y: 40, m: 20}
              ],
              interiors: []
            }
          ])
      }

      assert MultiPolygonM.from_wkt!(wkt) == {multi_polygon, 1234}
    end

    test "raises an exception for invalid WKT" do
      message = "expected 'SRID', 'Geometry' or 'SRID;Geometry' at 1:0, got: 'Pluto'"

      assert_raise Geometry.Error, message, fn ->
        MultiPolygonM.from_wkt!("Pluto")
      end
    end
  end

  describe "to_wkt/2" do
    test "returns wkt-string" do
      multi_polygon = %MultiPolygonM{
        polygons:
          MapSet.new([
            %PolygonM{
              exterior: [
                %PointM{x: 20, y: 35, m: 10},
                %PointM{x: 10, y: 30, m: 20},
                %PointM{x: 10, y: 10, m: 15},
                %PointM{x: 30, y: 5, m: 15},
                %PointM{x: 45, y: 20, m: 16},
                %PointM{x: 20, y: 35, m: 10}
              ],
              interiors: [
                [
                  %PointM{x: 30, y: 20, m: 15},
                  %PointM{x: 20, y: 15, m: 10},
                  %PointM{x: 20, y: 25, m: 25},
                  %PointM{x: 30, y: 20, m: 15}
                ]
              ]
            },
            %PolygonM{
              exterior: [
                %PointM{x: 40, y: 40, m: 20},
                %PointM{x: 20, y: 45, m: 10},
                %PointM{x: 45, y: 30, m: 30},
                %PointM{x: 40, y: 40, m: 20}
              ],
              interiors: []
            }
          ])
      }

      wkt = MultiPolygonM.to_wkt(multi_polygon)

      assert String.starts_with?(wkt, "MultiPolygon M")

      assert wkt =~
               "((20 35 10, 10 30 20, 10 10 15, 30 5 15, 45 20 16, 20 35 10)" <>
                 ", (30 20 15, 20 15 10, 20 25 25, 30 20 15))"

      assert wkt =~ "((40 40 20, 20 45 10, 45 30 30, 40 40 20))"

      wkt_srid = MultiPolygonM.to_wkt(multi_polygon, srid: 478)

      assert String.starts_with?(wkt_srid, "SRID=478;MultiPolygon M")

      assert wkt_srid =~
               "((20 35 10, 10 30 20, 10 10 15, 30 5 15, 45 20 16, 20 35 10)" <>
                 ", (30 20 15, 20 15 10, 20 25 25, 30 20 15))"

      assert wkt_srid =~ "((40 40 20, 20 45 10, 45 30 30, 40 40 20))"
    end
  end

  describe "from_wkb/1" do
    test "returns a MultiPolygonM (ndr)" do
      wkb = """
      01\
      06000040\
      02000000\
      01\
      03000040\
      02000000\
      04000000\
      000000000000F03F000000000000F03F0000000000001040\
      0000000000002240000000000000F03F0000000000001440\
      000000000000224000000000000020400000000000001840\
      000000000000F03F000000000000F03F0000000000001040\
      04000000\
      000000000000184000000000000000400000000000000840\
      0000000000001C4000000000000000400000000000001C40\
      0000000000001C4000000000000008400000000000001040\
      000000000000184000000000000000400000000000000840\
      01\
      03000040\
      01000000\
      04000000\
      000000000000184000000000000000400000000000001040\
      000000000000204000000000000000400000000000001440\
      000000000000204000000000000010400000000000001840\
      000000000000184000000000000000400000000000001040\
      """

      multi_polygon = %MultiPolygonM{
        polygons:
          MapSet.new([
            %PolygonM{
              exterior: [
                %PointM{x: 1.0, y: 1.0, m: 4.0},
                %PointM{x: 9.0, y: 1.0, m: 5.0},
                %PointM{x: 9.0, y: 8.0, m: 6.0},
                %PointM{x: 1.0, y: 1.0, m: 4.0}
              ],
              interiors: [
                [
                  %PointM{x: 6.0, y: 2.0, m: 3.0},
                  %PointM{x: 7.0, y: 2.0, m: 7.0},
                  %PointM{x: 7.0, y: 3.0, m: 4.0},
                  %PointM{x: 6.0, y: 2.0, m: 3.0}
                ]
              ]
            },
            %PolygonM{
              exterior: [
                %PointM{x: 6.0, y: 2.0, m: 4.0},
                %PointM{x: 8.0, y: 2.0, m: 5.0},
                %PointM{x: 8.0, y: 4.0, m: 6.0},
                %PointM{x: 6.0, y: 2.0, m: 4.0}
              ],
              interiors: []
            }
          ])
      }

      assert MultiPolygonM.from_wkb(wkb) == {:ok, multi_polygon}
    end
  end

  describe "to_wkb/2" do
    test "returns WKB for PolygonM" do
      wkb_start = "0106000040020000000103000040"

      multi_polygon = %MultiPolygonM{
        polygons:
          MapSet.new([
            %PolygonM{
              exterior: [
                %PointM{x: 1.0, y: 1.0, m: 4.0},
                %PointM{x: 9.0, y: 1.0, m: 5.0},
                %PointM{x: 9.0, y: 8.0, m: 6.0},
                %PointM{x: 1.0, y: 1.0, m: 4.0}
              ],
              interiors: [
                [
                  %PointM{x: 6.0, y: 2.0, m: 3.0},
                  %PointM{x: 7.0, y: 2.0, m: 7.0},
                  %PointM{x: 7.0, y: 3.0, m: 4.0},
                  %PointM{x: 6.0, y: 2.0, m: 3.0}
                ]
              ]
            },
            %PolygonM{
              exterior: [
                %PointM{x: 6.0, y: 2.0, m: 4.0},
                %PointM{x: 8.0, y: 2.0, m: 5.0},
                %PointM{x: 8.0, y: 4.0, m: 6.0},
                %PointM{x: 6.0, y: 2.0, m: 4.0}
              ],
              interiors: []
            }
          ])
      }

      assert result = MultiPolygonM.to_wkb(multi_polygon)
      assert String.starts_with?(result, wkb_start)
      assert MultiPolygonM.from_wkb!(result) == multi_polygon
    end
  end

  describe "from_wkb!/1" do
    test "returns a MultiPolygonM (ndr)" do
      wkb = """
      01\
      06000040\
      02000000\
      01\
      03000040\
      02000000\
      04000000\
      000000000000F03F000000000000F03F0000000000001040\
      0000000000002240000000000000F03F0000000000001440\
      000000000000224000000000000020400000000000001840\
      000000000000F03F000000000000F03F0000000000001040\
      04000000\
      000000000000184000000000000000400000000000000840\
      0000000000001C4000000000000000400000000000001C40\
      0000000000001C4000000000000008400000000000001040\
      000000000000184000000000000000400000000000000840\
      01\
      03000040\
      01000000\
      04000000\
      000000000000184000000000000000400000000000001040\
      000000000000204000000000000000400000000000001440\
      000000000000204000000000000010400000000000001840\
      000000000000184000000000000000400000000000001040\
      """

      multi_polygon = %MultiPolygonM{
        polygons:
          MapSet.new([
            %PolygonM{
              exterior: [
                %PointM{x: 1.0, y: 1.0, m: 4.0},
                %PointM{x: 9.0, y: 1.0, m: 5.0},
                %PointM{x: 9.0, y: 8.0, m: 6.0},
                %PointM{x: 1.0, y: 1.0, m: 4.0}
              ],
              interiors: [
                [
                  %PointM{x: 6.0, y: 2.0, m: 3.0},
                  %PointM{x: 7.0, y: 2.0, m: 7.0},
                  %PointM{x: 7.0, y: 3.0, m: 4.0},
                  %PointM{x: 6.0, y: 2.0, m: 3.0}
                ]
              ]
            },
            %PolygonM{
              exterior: [
                %PointM{x: 6.0, y: 2.0, m: 4.0},
                %PointM{x: 8.0, y: 2.0, m: 5.0},
                %PointM{x: 8.0, y: 4.0, m: 6.0},
                %PointM{x: 6.0, y: 2.0, m: 4.0}
              ],
              interiors: []
            }
          ])
      }

      assert MultiPolygonM.from_wkb!(wkb) == multi_polygon
    end

    test "raises an error for an invalid WKB" do
      message = "expected endian flag '00' or '01', at position 0"

      assert_raise Geometry.Error, message, fn ->
        MultiPolygonM.from_wkb!("")
      end
    end
  end
end
